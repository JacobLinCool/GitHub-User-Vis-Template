(function(){"use strict";function m(p){var s;const r=new Set(p.map(a=>Object.keys(a.langs)).flat().sort()),o=new Map;for(const a of r)a!=="unknown"&&o.set(a,[]);const e=new Map;for(const a of p){const u=a.date.toISOString().slice(0,7);if(!e.has(u)){e.set(u,e.size);for(const i of r)(s=o.get(i))==null||s.push(0)}for(const[i,f]of Object.entries(a.langs)){const l=o.get(i);l&&(l[e.get(u)]+=f)}}return{languages:o,months:e}}function g(p){const r=p.commits,o=[{type_name:"test",count:0,color:"red"},{type_name:"docs",count:0,color:"orange"},{type_name:"ci",count:0,color:"blue"},{type_name:"code",count:0,color:"green"},{type_name:"unknown",count:0,color:"gray"}];for(const e of r){let s=!1;for(const a of Object.keys(e.langs))if(p.disabled.has(a)){s=!0;break}s||(o[0].count+=e.types.test===void 0?0:e.types.test,o[1].count+=e.types.docs===void 0?0:e.types.docs,o[2].count+=e.types.ci===void 0?0:e.types.ci,o[3].count+=e.types.code===void 0?0:e.types.code,o[4].count+=e.types.undefined===void 0?0:e.types.undefined)}return o.sort((e,s)=>e.type_name==="unknown"?1:s.type_name==="unknown"?-1:s.count-e.count),o}function y(p){const r=p.issues,[o,...e]=Object.entries(r.reduce((t,n)=>(n.participants.forEach(c=>{t[c]=(t[c]||0)+1}),t),{})).sort((t,n)=>n[1]-t[1]).map(([t,n])=>({name:t,count:n,x:0,y:0,type:"user"})),s=Object.entries(r.reduce((t,n)=>{if(n.repo in t){t[n.repo][0]++;for(const c of n.participants)t[n.repo][1][c]=(t[n.repo][1][c]||0)+1}else{t[n.repo]=[1,{}];for(const c of n.participants)t[n.repo][1][c]=1}return t},{})).sort((t,n)=>n[1][0]-t[1][0]).map(([t,[n,c]])=>({name:t,count:n,x:0,y:0,type:"repo",users:c})),a=Math.max(...s.map(t=>t.count),...e.map(t=>t.count));for(let t=e.length-1;t>=0;t--)e[t].count<a*p.threshold&&e.splice(t,1);const u=new Set(e.map(t=>t.name));for(let t=s.length-1;t>=0;t--)Object.keys(s[t].users).some(n=>u.has(n))||s.splice(t,1);const i=[o,...s,...e],f=new Set(i.map(t=>t.name)),l=[...s.map(t=>({source:o.name,target:t.name,value:t.count})),...s.map(t=>Object.entries(t.users).map(([n,c])=>({source:t.name,target:n,value:c}))).flat().filter(t=>t.target!==o.name)].filter(t=>f.has(t.source)&&f.has(t.target));return{self:o,nodes:i,links:l,max:a}}onmessage=async p=>{const{id:r,type:o,data:e}=p.data;o==="langs"&&postMessage({id:r,data:m(e)}),o==="types"&&postMessage({id:r,data:g(e)}),o==="graph"&&postMessage({id:r,data:y(e)})}})();
